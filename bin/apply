#!/usr/bin/env bash
# Apply the dotfiles devcontainer template to a project

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Default values
TEMPLATE_ID="ghcr.io/technicalpickles/dotfiles-devcontainer/dotfiles:latest"
INSTALL_ENV_VARS="${INSTALL_ENV_VARS:-}"
DOTFILES_REPO="${DOTFILES_REPO:-https://github.com/technicalpickles/dotfiles.git}"
DOTFILES_BRANCH="${DOTFILES_BRANCH:-main}"
USER_SHELL="${USER_SHELL:-/usr/bin/fish}"
USER_SHELL_NAME="${USER_SHELL_NAME:-}"
TARGET_DIR=""
VERBOSE="${VERBOSE:-false}"
DOTFILES_REPO_EXPLICIT=false

# Normalize git URLs from SSH to HTTPS format
normalize_git_url() {
  local url="$1"
  # Convert SSH to HTTPS: git@github.com:user/repo.git -> https://github.com/user/repo.git
  if [[ "$url" =~ ^git@([^:]+):(.+)$ ]]; then
    echo "https://${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
  else
    echo "$url"
  fi
}

# Detect dotfiles repository from multiple sources
detect_dotfiles_repo() {
  local DETECTED_REPO_ENV=""
  local DETECTED_REPO_GITCONFIG=""
  local DETECTED_REPO_LOCAL=""
  local DETECTED_USER_GH=""

  [[ "$VERBOSE" == "true" ]] && echo "üîç Auto-detecting dotfiles repository..."

  # Source 1: Environment variable (already captured in DOTFILES_REPO)
  if [[ -n "${DOTFILES_REPO:-}" && "$DOTFILES_REPO" != "https://github.com/technicalpickles/dotfiles.git" ]]; then
    DETECTED_REPO_ENV="$DOTFILES_REPO"
    [[ "$VERBOSE" == "true" ]] && echo "   ‚Ä¢ Found via \$DOTFILES_REPO: $DETECTED_REPO_ENV"
  fi

  # Source 2: Git config github.user
  if command -v git &> /dev/null; then
    local github_user
    github_user=$(git config --get github.user 2>/dev/null || echo "")
    if [[ -n "$github_user" ]]; then
      DETECTED_REPO_GITCONFIG="https://github.com/${github_user}/dotfiles.git"
      [[ "$VERBOSE" == "true" ]] && echo "   ‚Ä¢ Found via git config: $DETECTED_REPO_GITCONFIG"
    fi
  fi

  # Source 3: Local dotfiles directories
  for local_path in "$HOME/dotfiles" "$HOME/.dotfiles"; do
    if [[ -d "$local_path/.git" ]]; then
      local remote_url
      remote_url=$(cd "$local_path" && git config --get remote.origin.url 2>/dev/null || echo "")
      if [[ -n "$remote_url" ]]; then
        DETECTED_REPO_LOCAL=$(normalize_git_url "$remote_url")
        [[ "$VERBOSE" == "true" ]] && echo "   ‚Ä¢ Found via local ${local_path}: $DETECTED_REPO_LOCAL"
        break  # Prefer ~/dotfiles over ~/.dotfiles
      fi
    fi
  done

  # Source 4: GitHub CLI authenticated user
  if command -v gh &> /dev/null; then
    local gh_user
    gh_user=$(gh auth status 2>&1 | grep "Logged in" | sed -n 's/.*account \([^ ]*\).*/\1/p' || echo "")
    if [[ -n "$gh_user" ]]; then
      DETECTED_USER_GH="$gh_user"
      [[ "$VERBOSE" == "true" ]] && echo "   ‚Ä¢ Found via gh auth: $DETECTED_USER_GH"
    fi
  fi

  # Decision heuristics
  local CHOSEN_REPO=""
  local DETECTION_METHOD=""
  local HAS_INCONSISTENCY=false
  local INCONSISTENCY_MESSAGE=""

  # Check for consistency between sources
  local consistent_repo=""
  if [[ -n "$DETECTED_REPO_LOCAL" && -n "$DETECTED_REPO_GITCONFIG" && "$DETECTED_REPO_LOCAL" == "$DETECTED_REPO_GITCONFIG" ]]; then
    consistent_repo="$DETECTED_REPO_LOCAL"
    DETECTION_METHOD="git config and local repo (validated)"
  fi

  # Validate with gh auth if available
  if [[ -n "$DETECTED_USER_GH" ]]; then
    local gh_repo="https://github.com/${DETECTED_USER_GH}/dotfiles.git"
    if [[ -n "$consistent_repo" && "$consistent_repo" == "$gh_repo" ]]; then
      DETECTION_METHOD="authenticated source (all sources match)"
    elif [[ -z "$consistent_repo" ]]; then
      consistent_repo="$gh_repo"
      DETECTION_METHOD="authenticated source (gh auth)"
    fi
  fi

  # Detect inconsistencies
  if [[ -n "$DETECTED_REPO_GITCONFIG" && -n "$DETECTED_REPO_LOCAL" && "$DETECTED_REPO_GITCONFIG" != "$DETECTED_REPO_LOCAL" ]]; then
    HAS_INCONSISTENCY=true
    INCONSISTENCY_MESSAGE="   ‚ö†Ô∏è  Multiple dotfiles repos detected:\n       - git config: $DETECTED_REPO_GITCONFIG\n       - local ~/dotfiles: $DETECTED_REPO_LOCAL"
  fi

  # Priority when inconsistent: authenticated > git config > local
  if [[ -n "$consistent_repo" ]]; then
    CHOSEN_REPO="$consistent_repo"
  elif [[ -n "$DETECTED_USER_GH" ]]; then
    CHOSEN_REPO="https://github.com/${DETECTED_USER_GH}/dotfiles.git"
    DETECTION_METHOD="authenticated source (gh auth)"
  elif [[ -n "$DETECTED_REPO_GITCONFIG" ]]; then
    CHOSEN_REPO="$DETECTED_REPO_GITCONFIG"
    DETECTION_METHOD="git config"
  elif [[ -n "$DETECTED_REPO_LOCAL" ]]; then
    CHOSEN_REPO="$DETECTED_REPO_LOCAL"
    DETECTION_METHOD="local repository"
  fi

  # Output results
  if [[ -n "$CHOSEN_REPO" ]]; then
    if [[ "$VERBOSE" != "true" ]]; then
      echo "üîç Auto-detecting dotfiles repository..."
    fi

    if [[ "$HAS_INCONSISTENCY" == "true" ]]; then
      echo -e "$INCONSISTENCY_MESSAGE"
      echo "   Using $DETECTION_METHOD: $CHOSEN_REPO"
      echo "   (Set \$DOTFILES_REPO or use --repo to override)"
    else
      echo "   ‚úì Found via $DETECTION_METHOD: $CHOSEN_REPO"
      if [[ "$VERBOSE" == "true" && "$DETECTION_METHOD" == *"validated"* ]]; then
        echo "   ‚úì Validated: Local ~/dotfiles matches git config"
      fi
      echo "   Using: $CHOSEN_REPO"
    fi

    DOTFILES_REPO="$CHOSEN_REPO"
  else
    [[ "$VERBOSE" == "true" ]] && echo "   ‚Ä¢ No dotfiles repo detected, using template default"
  fi
}

usage() {
  cat << 'EOF'
Usage: apply [OPTIONS] [TARGET_DIR]

Apply the dotfiles devcontainer template to a project directory.

This script detects whether it's running from within the dotfiles-devcontainer
repository or from elsewhere (e.g., curl | bash) and adjusts its behavior:

  - From repo: Uses local template files from src/dotfiles/
  - From elsewhere: Uses published template from GHCR

ARGUMENTS:
  TARGET_DIR         Target directory to apply template to (default: current directory)
                     Use "." for current directory

OPTIONS:
  --env KEY=VALUE    Environment variable to set before running dotfiles install.sh
                     Can be specified multiple times
  --repo URL         Dotfiles repository URL (default: auto-detected)
  --branch BRANCH    Dotfiles branch (default: main)
  --shell PATH       Login shell path for the vscode user (default: /usr/bin/fish)
  --verbose          Show detailed detection information
  -h, --help         Show this help message

ENVIRONMENT VARIABLES:
  INSTALL_ENV_VARS   Environment variables in KEY1=value1,KEY2=value2 format
  DOTFILES_REPO      Same as --repo
  DOTFILES_BRANCH    Same as --branch
  USER_SHELL         Same as --shell
  USER_SHELL_NAME    Override the terminal profile name (default: derived from USER_SHELL)

EXAMPLES:
  # Apply to current directory with defaults
  bin/apply .

  # Apply to a specific project directory
  bin/apply ~/projects/my-app

  # Use custom dotfiles with environment variables
  bin/apply --repo https://github.com/myuser/dotfiles.git --env DOTFILES_ROLE=devcontainer .

  # Multiple environment variables
  bin/apply --env ROLE=work --env ENV=production ~/work/project

  # Via curl (uses published template)
  curl -fsSL https://raw.githubusercontent.com/technicalpickles/dotfiles-devcontainer/main/bin/apply | bash -s -- .

WORKFLOW:
  1. Detects if running from dotfiles-devcontainer repo or standalone
  2. Installs @devcontainers/cli if not present
  3. Applies template with specified options
  4. Creates .devcontainer/ configuration in target directory

EOF
}

# Collect env vars as KEY=VALUE entries (works with bash 3.x)
ENV_VARS=()

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    -h|--help)
      usage
      exit 0
      ;;
    --env)
      # Parse KEY=VALUE and add to associative array
      if [[ "$2" =~ ^([^=]+)=(.*)$ ]]; then
        ENV_VARS+=("${BASH_REMATCH[1]}=${BASH_REMATCH[2]}")
      else
        echo "Error: --env requires KEY=VALUE format, got: $2" >&2
        exit 1
      fi
      shift 2
      ;;
    --repo)
      DOTFILES_REPO="$2"
      DOTFILES_REPO_EXPLICIT=true
      shift 2
      ;;
    --branch)
      DOTFILES_BRANCH="$2"
      shift 2
      ;;
    --shell)
      USER_SHELL="$2"
      shift 2
      ;;
    --verbose)
      VERBOSE="true"
      shift
      ;;
    -*)
      echo "Error: Unknown option: $1" >&2
      echo "Use --help for usage information" >&2
      exit 1
      ;;
    *)
      TARGET_DIR="$1"
      shift
      ;;
  esac
done

# Default to current directory if not specified
if [[ -z "$TARGET_DIR" ]]; then
  TARGET_DIR="."
fi

# Convert to absolute path
TARGET_DIR="$(cd "$TARGET_DIR" 2>/dev/null && pwd)" || {
  echo "Error: Target directory does not exist: $TARGET_DIR" >&2
  exit 1
}

if [[ -z "$USER_SHELL_NAME" ]]; then
  USER_SHELL_NAME="$(basename "$USER_SHELL")"
fi

# Track if repo was explicitly set (for auto-detection)
DOTFILES_REPO_EXPLICIT=false
if [[ -n "${DOTFILES_REPO:-}" && "$DOTFILES_REPO" != "https://github.com/technicalpickles/dotfiles.git" ]]; then
  # Check if it was set via --repo flag or env var (not the default)
  DOTFILES_REPO_EXPLICIT=true
fi

# Auto-detect dotfiles repo if not explicitly set
if [[ "$DOTFILES_REPO_EXPLICIT" == "false" ]]; then
  detect_dotfiles_repo
else
  # Explicit override was used
  echo "üîç Using explicitly specified dotfiles repository"
  echo "   Repo: $DOTFILES_REPO"
fi

echo
echo "Dotfiles Dev Container Template Applier"
echo "========================================"
echo

# Detect context: are we running from the repo or standalone?
IS_IN_REPO=false
if [[ -f "$REPO_ROOT/src/dotfiles/devcontainer-template.json" ]]; then
  IS_IN_REPO=true
fi

if [[ "$IS_IN_REPO" == "true" ]]; then
  echo "üì¶ Running from dotfiles-devcontainer repository"
  echo "   Will use local template files from: src/dotfiles/"
  TEMPLATE_SOURCE="$REPO_ROOT/src/dotfiles"
else
  echo "üåê Running standalone (not in repo)"
  echo "   Will use published template: $TEMPLATE_ID"
  TEMPLATE_SOURCE="$TEMPLATE_ID"
fi

echo
echo "Configuration:"
echo "  Target directory: $TARGET_DIR"
echo "  Dotfiles repo: $DOTFILES_REPO"
echo "  Dotfiles branch: $DOTFILES_BRANCH"
echo "  User shell: $USER_SHELL (profile: $USER_SHELL_NAME)"
# Temporarily disable unbound variable check for associative array
set +u
if [[ ${#ENV_VARS[@]} -gt 0 ]]; then
  echo "  Environment variables:"
  for kv in "${ENV_VARS[@]}"; do
    echo "    $kv"
  done
fi
set -u
echo

# Check if devcontainer CLI is installed
if ! command -v devcontainer &> /dev/null; then
  echo "‚ö†Ô∏è  devcontainer CLI not found"
  echo "üì¶ Installing @devcontainers/cli..."

  # Check if npx is available
  if command -v npx &> /dev/null; then
    echo "   Using npx (no installation needed)"
    DEVCONTAINER_CMD="npx --yes @devcontainers/cli"
  elif command -v npm &> /dev/null; then
    echo "   Installing globally with npm..."
    npm install -g @devcontainers/cli
    DEVCONTAINER_CMD="devcontainer"
  else
    echo "Error: Neither npx nor npm found. Please install Node.js first:" >&2
    echo "  https://nodejs.org/" >&2
    exit 1
  fi
else
  echo "‚úì devcontainer CLI found"
  DEVCONTAINER_CMD="devcontainer"
fi

echo

# Check if target directory already has devcontainer config
if [[ -d "$TARGET_DIR/.devcontainer" ]]; then
  echo "‚ö†Ô∏è  Warning: .devcontainer/ already exists in target directory"
  read -p "   Do you want to overwrite it? (y/N) " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Aborted."
    exit 1
  fi
  echo "   Will overwrite existing configuration"
  echo
fi

# Apply the template
echo "üöÄ Applying template to: $TARGET_DIR"
echo

cd "$TARGET_DIR"

if [[ "$IS_IN_REPO" == "true" ]]; then
  # Running from repo - copy files manually since we can't use templates apply with local path
  echo "üìã Copying template files..."

  # Create .devcontainer directory
  mkdir -p .devcontainer

  # Copy devcontainer files
  cp "$TEMPLATE_SOURCE/.devcontainer/devcontainer.json" .devcontainer/
  cp "$TEMPLATE_SOURCE/.devcontainer/Dockerfile" .devcontainer/
  cp "$TEMPLATE_SOURCE/.devcontainer/post-create.sh" .devcontainer/

  # Replace template options with actual values
  echo "üîß Configuring template options..."

  # Build containerEnv JSON for environment variables
  set +u
  if [[ ${#ENV_VARS[@]} -gt 0 ]]; then
    CONTAINER_ENV_JSON="{"
    FIRST=true
    for kv in "${ENV_VARS[@]}"; do
      key="${kv%%=*}"
      value="${kv#*=}"
      if [[ "$FIRST" == "true" ]]; then
        FIRST=false
      else
        CONTAINER_ENV_JSON+=","
      fi
      # Properly escape JSON values
      VALUE=$(printf '%s' "$value" | jq -R .)
      CONTAINER_ENV_JSON+="\"$key\":$VALUE"
    done
    CONTAINER_ENV_JSON+="}"
  else
    CONTAINER_ENV_JSON="{}"
  fi
  set -u

  # Replace placeholders in devcontainer.json
  sed -i.bak "s|\${templateOption:installEnvVars}|$CONTAINER_ENV_JSON|g" .devcontainer/devcontainer.json
  sed -i.bak "s|\${templateOption:dotfilesRepo}|$DOTFILES_REPO|g" .devcontainer/devcontainer.json
  sed -i.bak "s|\${templateOption:dotfilesBranch}|$DOTFILES_BRANCH|g" .devcontainer/devcontainer.json
  sed -i.bak "s|\${templateOption:userShell}|$USER_SHELL|g" .devcontainer/devcontainer.json
  sed -i.bak "s|\${templateOption:userShellName}|$USER_SHELL_NAME|g" .devcontainer/devcontainer.json
  rm .devcontainer/devcontainer.json.bak

  # Replace placeholders in Dockerfile
  sed -i.bak "s|\${templateOption:dotfilesRepo}|$DOTFILES_REPO|g" .devcontainer/Dockerfile
  sed -i.bak "s|\${templateOption:dotfilesBranch}|$DOTFILES_BRANCH|g" .devcontainer/Dockerfile
  sed -i.bak "s|\${templateOption:userShell}|$USER_SHELL|g" .devcontainer/Dockerfile
  rm .devcontainer/Dockerfile.bak

  # Replace placeholders in post-create.sh
  sed -i.bak "s|\${templateOption:dotfilesRepo}|$DOTFILES_REPO|g" .devcontainer/post-create.sh
  sed -i.bak "s|\${templateOption:dotfilesBranch}|$DOTFILES_BRANCH|g" .devcontainer/post-create.sh
  rm .devcontainer/post-create.sh.bak

  echo "‚úì Template files copied and configured"
else
  # Running standalone - use devcontainer CLI with published template
  # Build template args for environment variables
  ENV_ARGS=""
  set +u
  if [[ ${#ENV_VARS[@]} -gt 0 ]]; then
    ENV_JSON="{"
    FIRST=true
    for kv in "${ENV_VARS[@]}"; do
      key="${kv%%=*}"
      value="${kv#*=}"
      if [[ "$FIRST" == "true" ]]; then
        FIRST=false
      else
        ENV_JSON+=","
      fi
      VALUE=$(printf '%s' "$value" | jq -R .)
      ENV_JSON+="\"$key\":$VALUE"
    done
    ENV_JSON+="}"
    ENV_ARGS="--template-args installEnvVars='$ENV_JSON'"
  fi
  set -u

  $DEVCONTAINER_CMD templates apply \
    --template-id "$TEMPLATE_ID" \
    --template-args dotfilesRepo="$DOTFILES_REPO" \
    --template-args dotfilesBranch="$DOTFILES_BRANCH" \
    --template-args userShell="$USER_SHELL" \
    --template-args userShellName="$USER_SHELL_NAME" \
    $ENV_ARGS

  echo "‚úì Template applied via devcontainer CLI"
fi

echo
echo "‚úÖ Success! Dotfiles devcontainer template has been applied."
echo
echo "Next steps:"
echo "  1. Review the configuration in .devcontainer/"
echo "  2. Open this directory in VS Code"
echo "  3. Press Cmd+Shift+P and select 'Dev Containers: Reopen in Container'"
echo
echo "For better performance on macOS, consider using:"
echo "  'Dev Containers: Clone Repository in Container Volume...'"
echo "  See: https://github.com/technicalpickles/dotfiles-devcontainer#macos-performance-optimization"
echo
