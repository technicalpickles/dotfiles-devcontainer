#!/usr/bin/env bash
# Apply the dotfiles devcontainer template to a project

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Default values
TEMPLATE_ID="ghcr.io/technicalpickles/dotfiles-devcontainer/dotfiles:latest"
INSTALL_ENV_VARS="${INSTALL_ENV_VARS:-}"
DOTFILES_REPO="${DOTFILES_REPO:-https://github.com/technicalpickles/dotfiles.git}"
DOTFILES_BRANCH="${DOTFILES_BRANCH:-main}"
USER_SHELL="${USER_SHELL:-/usr/bin/fish}"
USER_SHELL_NAME="${USER_SHELL_NAME:-}"
PLATFORM_OVERRIDE="${PLATFORM_OVERRIDE:-}"
PLATFORM_DETECTED=""
PLATFORM_SELECTED=""
TARGET_DIR=""
VERBOSE="${VERBOSE:-false}"
DOTFILES_REPO_EXPLICIT=false
DOTFILES_REPO_WAS_FLAG=false
DIND_FEATURE_REF="${DIND_FEATURE_REF:-}"
AWS_CLI_FEATURE_REF="${AWS_CLI_FEATURE_REF:-}"
KEEP_VENDORED_FEATURES=false
MODE=""
SKIP_DIND=false

# Normalize git URLs from SSH to HTTPS format
normalize_git_url() {
  local url="$1"
  # Convert SSH to HTTPS: git@github.com:user/repo.git -> https://github.com/user/repo.git
  if [[ "$url" =~ ^git@([^:]+):(.+)$ ]]; then
    echo "https://${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
  else
    echo "$url"
  fi
}

# Detect dotfiles repository from multiple sources
detect_dotfiles_repo() {
  local DETECTED_REPO_ENV=""
  local DETECTED_REPO_GITCONFIG=""
  local DETECTED_REPO_LOCAL=""
  local DETECTED_USER_GH=""

  [[ "$VERBOSE" == "true" ]] && echo "üîç Auto-detecting dotfiles repository..."

  # Source 1: Environment variable (already captured in DOTFILES_REPO)
  if [[ -n "${DOTFILES_REPO:-}" && "$DOTFILES_REPO" != "https://github.com/technicalpickles/dotfiles.git" ]]; then
    DETECTED_REPO_ENV="$DOTFILES_REPO"
    [[ "$VERBOSE" == "true" ]] && echo "   ‚Ä¢ Found via \$DOTFILES_REPO: $DETECTED_REPO_ENV"
  fi

  # Source 2: Git config github.user
  if command -v git &> /dev/null; then
    local github_user
    github_user=$(git config --get github.user 2>/dev/null || echo "")
    if [[ -n "$github_user" ]]; then
      DETECTED_REPO_GITCONFIG="https://github.com/${github_user}/dotfiles.git"
      [[ "$VERBOSE" == "true" ]] && echo "   ‚Ä¢ Found via git config: $DETECTED_REPO_GITCONFIG"
    fi
  fi

  # Source 3: Local dotfiles directories
  for local_path in "$HOME/dotfiles" "$HOME/.dotfiles"; do
    if [[ -d "$local_path/.git" ]]; then
      local remote_url
      remote_url=$(cd "$local_path" && git config --get remote.origin.url 2>/dev/null || echo "")
      if [[ -n "$remote_url" ]]; then
        DETECTED_REPO_LOCAL=$(normalize_git_url "$remote_url")
        [[ "$VERBOSE" == "true" ]] && echo "   ‚Ä¢ Found via local ${local_path}: $DETECTED_REPO_LOCAL"
        break  # Prefer ~/dotfiles over ~/.dotfiles
      fi
    fi
  done

  # Source 4: GitHub CLI authenticated user
  if command -v gh &> /dev/null; then
    local gh_user
    gh_user=$(gh auth status 2>&1 | grep "Logged in" | sed -n 's/.*account \([^ ]*\).*/\1/p' || echo "")
    if [[ -n "$gh_user" ]]; then
      DETECTED_USER_GH="$gh_user"
      [[ "$VERBOSE" == "true" ]] && echo "   ‚Ä¢ Found via gh auth: $DETECTED_USER_GH"
    fi
  fi

  # Decision heuristics
  local CHOSEN_REPO=""
  local DETECTION_METHOD=""
  local HAS_INCONSISTENCY=false
  local INCONSISTENCY_MESSAGE=""

  # Check for consistency between sources
  local consistent_repo=""
  if [[ -n "$DETECTED_REPO_LOCAL" && -n "$DETECTED_REPO_GITCONFIG" && "$DETECTED_REPO_LOCAL" == "$DETECTED_REPO_GITCONFIG" ]]; then
    consistent_repo="$DETECTED_REPO_LOCAL"
    DETECTION_METHOD="git config and local repo (validated)"
  fi

  # Validate with gh auth if available
  if [[ -n "$DETECTED_USER_GH" ]]; then
    local gh_repo="https://github.com/${DETECTED_USER_GH}/dotfiles.git"
    if [[ -n "$consistent_repo" && "$consistent_repo" == "$gh_repo" ]]; then
      DETECTION_METHOD="authenticated source (all sources match)"
    elif [[ -z "$consistent_repo" ]]; then
      consistent_repo="$gh_repo"
      DETECTION_METHOD="authenticated source (gh auth)"
    fi
  fi

  # Detect inconsistencies
  if [[ -n "$DETECTED_REPO_GITCONFIG" && -n "$DETECTED_REPO_LOCAL" && "$DETECTED_REPO_GITCONFIG" != "$DETECTED_REPO_LOCAL" ]]; then
    HAS_INCONSISTENCY=true
    INCONSISTENCY_MESSAGE="   ‚ö†Ô∏è  Multiple dotfiles repos detected:\n       - git config: $DETECTED_REPO_GITCONFIG\n       - local ~/dotfiles: $DETECTED_REPO_LOCAL"
  fi

  # Priority when inconsistent: authenticated > git config > local
  if [[ -n "$consistent_repo" ]]; then
    CHOSEN_REPO="$consistent_repo"
  elif [[ -n "$DETECTED_USER_GH" ]]; then
    CHOSEN_REPO="https://github.com/${DETECTED_USER_GH}/dotfiles.git"
    DETECTION_METHOD="authenticated source (gh auth)"
  elif [[ -n "$DETECTED_REPO_GITCONFIG" ]]; then
    CHOSEN_REPO="$DETECTED_REPO_GITCONFIG"
    DETECTION_METHOD="git config"
  elif [[ -n "$DETECTED_REPO_LOCAL" ]]; then
    CHOSEN_REPO="$DETECTED_REPO_LOCAL"
    DETECTION_METHOD="local repository"
  fi

  # Output results
  if [[ -n "$CHOSEN_REPO" ]]; then
    if [[ "$VERBOSE" != "true" ]]; then
      echo "üîç Auto-detecting dotfiles repository..."
    fi

    if [[ "$HAS_INCONSISTENCY" == "true" ]]; then
      echo -e "$INCONSISTENCY_MESSAGE"
      echo "   Using $DETECTION_METHOD: $CHOSEN_REPO"
      echo "   (Set \$DOTFILES_REPO or use --repo to override)"
    else
      echo "   ‚úì Found via $DETECTION_METHOD: $CHOSEN_REPO"
      if [[ "$VERBOSE" == "true" && "$DETECTION_METHOD" == *"validated"* ]]; then
        echo "   ‚úì Validated: Local ~/dotfiles matches git config"
      fi
      echo "   Using: $CHOSEN_REPO"
    fi

    DOTFILES_REPO="$CHOSEN_REPO"
  else
    [[ "$VERBOSE" == "true" ]] && echo "   ‚Ä¢ No dotfiles repo detected, using template default"
  fi
}

detect_platform() {
  local arch
  arch="$(uname -m || true)"
  case "$arch" in
    arm64|aarch64)
      PLATFORM_DETECTED="linux/arm64"
      ;;
    x86_64|amd64)
      PLATFORM_DETECTED="linux/amd64"
      ;;
    *)
      PLATFORM_DETECTED=""
      ;;
  esac

  if [[ -n "$PLATFORM_OVERRIDE" ]]; then
    PLATFORM_SELECTED="$PLATFORM_OVERRIDE"
    echo "üîç Platform override provided: ${PLATFORM_SELECTED}"
  elif [[ -n "$PLATFORM_DETECTED" ]]; then
    PLATFORM_SELECTED="$PLATFORM_DETECTED"
    echo "üîç Detected host architecture: ${arch} -> ${PLATFORM_SELECTED}"
  else
    echo "‚ö†Ô∏è  Unsupported or unknown host architecture (${arch:-unknown}); not setting --platform. Docker may emit a platform warning."
    PLATFORM_SELECTED=""
  fi
}

prune_vendored_features() {
  local features_dir="$TARGET_DIR/.devcontainer/features"
  if [[ "$SKIP_DIND" == "true" ]]; then
    if [[ -d "$features_dir" ]]; then
      echo "üßπ Removing vendored features at ${features_dir} (DinD feature skipped)"
      rm -rf "$features_dir"
    fi
    return 0
  fi
  if [[ "$KEEP_VENDORED_FEATURES" == "true" ]]; then
    if [[ -d "$features_dir" ]]; then
      echo "‚ÑπÔ∏è  Keeping vendored features at ${features_dir} (local DinD feature ref in use)"
    fi
    return 0
  fi
  if [[ -d "$features_dir" ]]; then
    echo "üßπ Removing vendored features at ${features_dir} (template consumes published DinD feature from GHCR)"
    rm -rf "$features_dir"
  fi
}

override_feature_refs() {
  local dc_json="$TARGET_DIR/.devcontainer/devcontainer.json"
  if [[ ! -f "$dc_json" ]]; then
    echo "‚ö†Ô∏è  Unable to pin feature references; ${dc_json} not found" >&2
    return 0
  fi

  local refs_to_apply=""
  if [[ "$SKIP_DIND" != "true" && -n "$DIND_FEATURE_REF" ]]; then
    refs_to_apply="dind:${DIND_FEATURE_REF}"
  fi
  if [[ -n "$AWS_CLI_FEATURE_REF" ]]; then
    if [[ -n "$refs_to_apply" ]]; then
      refs_to_apply="${refs_to_apply},aws-cli:${AWS_CLI_FEATURE_REF}"
    else
      refs_to_apply="aws-cli:${AWS_CLI_FEATURE_REF}"
    fi
  fi

  if [[ -z "$refs_to_apply" ]]; then
    return 0
  fi

  echo "üîí Pinning feature references..."
  python3 - "$dc_json" "$refs_to_apply" "$TARGET_DIR" <<'PY'
import json, sys, re, pathlib, os

path = pathlib.Path(sys.argv[1]).resolve()
refs_raw = sys.argv[2]
dc_dir = path.parent  # Already resolved since path is resolved

raw = path.read_text()
clean = re.sub(r'^\s*//.*$', '', raw, flags=re.M)
obj = json.loads(clean)

def normalize_ref(raw_ref: str, dc_dir: pathlib.Path) -> str:
    sanitized = raw_ref
    for prefix in ("./.devcontainer/", ".devcontainer/"):
        if sanitized.startswith(prefix):
            sanitized = "./" + sanitized[len(prefix):]
            break

    if sanitized.startswith("file:"):
        ref_path = pathlib.Path(sanitized[5:])
    elif sanitized.startswith(("./", "../")):
        ref_path = pathlib.Path(sanitized)
    elif sanitized.startswith("/"):
        ref_path = pathlib.Path(sanitized)
    else:
        return sanitized  # non-local ref, leave as-is

    base_dir = dc_dir
    abs_ref = ref_path if ref_path.is_absolute() else (base_dir / ref_path).resolve()

    try:
        abs_ref.relative_to(dc_dir)
    except ValueError:
        raise SystemExit(f"Local feature must be inside the .devcontainer/ folder: {raw_ref}")

    rel_ref = os.path.relpath(abs_ref, dc_dir)
    if not rel_ref.startswith("."):
        rel_ref = f"./{rel_ref}"
    return rel_ref

# Parse refs_to_apply: "dind:ref,aws-cli:ref"
features = obj.get("features", {})
for pair in refs_raw.split(","):
    if ":" not in pair:
        continue
    feature_name, ref = pair.split(":", 1)
    normalized_ref = normalize_ref(ref, dc_dir)
    # Remove old refs for this feature
    to_remove = [k for k in features if feature_name in k]
    for k in to_remove:
        del features[k]
    features[normalized_ref] = {}
    print(f"   {feature_name}: {normalized_ref}")

obj["features"] = features
path.write_text(json.dumps(obj, indent=2) + "\n")
PY
}

is_local_dind_ref() {
  local ref="$1"
  if [[ -z "$ref" ]]; then
    return 1
  fi
  [[ "$ref" =~ ^(\.\/|/|file:) ]]
}

apply_mode_presets() {
  case "$MODE" in
    local-dev)
      if [[ -z "$DIND_FEATURE_REF" ]]; then
        DIND_FEATURE_REF="./features/dind"
      fi
      if [[ -z "$AWS_CLI_FEATURE_REF" ]]; then
        AWS_CLI_FEATURE_REF="./features/aws-cli"
      fi
      ;;
    ci-unpinned)
      # Use template defaults (published tag) unless caller overrides
      ;;
    ci-pinned)
      if [[ -z "$DIND_FEATURE_REF" ]]; then
        echo "Error: MODE ci-pinned requires DIND_FEATURE_REF pinned to a digest (ghcr...@sha256:<digest>)" >&2
        exit 1
      fi
      if [[ ! "$DIND_FEATURE_REF" =~ @sha256: ]]; then
        echo "Error: MODE ci-pinned requires DIND_FEATURE_REF pinned to a digest (@sha256:<digest>)" >&2
        exit 1
      fi
      if [[ -n "$AWS_CLI_FEATURE_REF" && ! "$AWS_CLI_FEATURE_REF" =~ @sha256: ]]; then
        echo "Error: MODE ci-pinned requires AWS_CLI_FEATURE_REF pinned to a digest (@sha256:<digest>)" >&2
        exit 1
      fi
      ;;
    release)
      if [[ -z "$DIND_FEATURE_REF" ]]; then
        echo "Error: MODE release requires DIND_FEATURE_REF pinned to a digest (no local refs)" >&2
        exit 1
      fi
      if [[ ! "$DIND_FEATURE_REF" =~ @sha256: ]]; then
        echo "Error: MODE release requires DIND_FEATURE_REF pinned to a digest (@sha256:<digest>)" >&2
        exit 1
      fi
      if is_local_dind_ref "$DIND_FEATURE_REF"; then
        echo "Error: MODE release does not allow local feature references" >&2
        exit 1
      fi
      if [[ -n "$AWS_CLI_FEATURE_REF" ]]; then
        if [[ ! "$AWS_CLI_FEATURE_REF" =~ @sha256: ]]; then
          echo "Error: MODE release requires AWS_CLI_FEATURE_REF pinned to a digest (@sha256:<digest>)" >&2
          exit 1
        fi
        if is_local_dind_ref "$AWS_CLI_FEATURE_REF"; then
          echo "Error: MODE release does not allow local feature references" >&2
          exit 1
        fi
      fi
      ;;
    *)
      echo "Error: Unknown MODE: ${MODE}" >&2
      exit 1
      ;;
  esac
}

usage() {
  cat << 'EOF'
Usage: apply MODE [OPTIONS] [TARGET_DIR]

Apply the dotfiles devcontainer template to a project directory.

This script detects whether it's running from within the dotfiles-devcontainer
repository or from elsewhere (e.g., curl | bash) and adjusts its behavior:

  - From repo: Uses local template files from src/dotfiles/
  - From elsewhere: Uses published template from GHCR

ARGUMENTS:
  MODE               Required. Preset for how to consume the DinD feature:
                       - local-dev   : use vendored DinD feature (./features/dind) for unpublished local work
                       - ci-unpinned : use the template's published feature tag (default behavior before modes)
                       - ci-pinned   : require a pinned digest via DIND_FEATURE_REF
                       - release     : require a pinned digest; disallow local refs
  TARGET_DIR         Target directory to apply template to (default: current directory)
                     Use "." for current directory

OPTIONS:
   --env KEY=VALUE    Environment variable to set before running dotfiles install.sh
                      Can be specified multiple times
   --repo URL         Dotfiles repository URL (default: auto-detected)
   --branch BRANCH    Dotfiles branch (default: main)
   --shell PATH       Login shell path for the vscode user (default: /usr/bin/fish)
   --platform VALUE   Optional platform override for base image (e.g., linux/arm64, linux/amd64)
   --no-dind          Skip Docker-in-Docker feature (exclude from devcontainer config)
   --verbose          Show detailed detection information
   -h, --help         Show this help message

ENVIRONMENT VARIABLES:
  INSTALL_ENV_VARS     Environment variables in KEY1=value1,KEY2=value2 format
  DOTFILES_REPO        Same as --repo
  DOTFILES_BRANCH      Same as --branch
  USER_SHELL           Same as --shell
  USER_SHELL_NAME      Override the terminal profile name (default: derived from USER_SHELL)
  PLATFORM_OVERRIDE    Same as --platform (forces platform flag in devcontainer build)
  DIND_FEATURE_REF     Pin dind feature to specific digest (ghcr.io/.../dind@sha256:<digest>)
  AWS_CLI_FEATURE_REF  Pin aws-cli feature to specific digest (ghcr.io/.../aws-cli@sha256:<digest>)

EXAMPLES:
  # Local development against vendored DinD feature (unpublished)
  bin/apply local-dev ~/projects/my-app

  # CI using latest published feature tag (previous default)
  bin/apply ci-unpinned ~/projects/my-app

  # CI/release with a pinned digest (required for release mode)
  DIND_FEATURE_REF="ghcr.io/technicalpickles/devcontainer-features/dind@sha256:<digest>" bin/apply ci-pinned .

  # CI/release with pinned digests for both features
  DIND_FEATURE_REF="ghcr.io/.../dind@sha256:<digest>" \
  AWS_CLI_FEATURE_REF="ghcr.io/.../aws-cli@sha256:<digest>" \
  bin/apply ci-pinned .

   # Custom dotfiles with env vars
   bin/apply ci-unpinned --repo https://github.com/myuser/dotfiles.git --env DOTFILES_ROLE=devcontainer .

   # Apply without Docker-in-Docker
   bin/apply ci-unpinned --no-dind /path/to/your/project

   # Via curl (uses published template); choose a mode
   curl -fsSL https://raw.githubusercontent.com/technicalpickles/dotfiles-devcontainer/main/bin/apply | bash -s -- ci-unpinned .

WORKFLOW:
  1. Detects if running from dotfiles-devcontainer repo or standalone
  2. Installs @devcontainers/cli if not present
  3. Applies template with specified options
  4. Creates .devcontainer/ configuration in target directory

EOF
}

# Collect env vars as KEY=VALUE entries (works with bash 3.x)
ENV_VARS=()

if [[ $# -eq 0 ]]; then
  usage
  exit 1
fi

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    -h|--help)
      usage
      exit 0
      ;;
    --env)
      # Parse KEY=VALUE and add to associative array
      if [[ "$2" =~ ^([^=]+)=(.*)$ ]]; then
        ENV_VARS+=("${BASH_REMATCH[1]}=${BASH_REMATCH[2]}")
      else
        echo "Error: --env requires KEY=VALUE format, got: $2" >&2
        exit 1
      fi
      shift 2
      ;;
    --repo)
      DOTFILES_REPO="$2"
      DOTFILES_REPO_WAS_FLAG=true
      shift 2
      ;;
    --branch)
      DOTFILES_BRANCH="$2"
      shift 2
      ;;
    --shell)
      USER_SHELL="$2"
      shift 2
      ;;
    --platform)
      PLATFORM_OVERRIDE="$2"
      shift 2
      ;;
    --verbose)
      VERBOSE="true"
      shift
      ;;
    --no-dind)
      SKIP_DIND="true"
      shift
      ;;
    -*)
      echo "Error: Unknown option: $1" >&2
      echo "Use --help for usage information" >&2
      exit 1
      ;;
    *)
      if [[ -z "$MODE" ]]; then
        MODE="$1"
      elif [[ -z "$TARGET_DIR" ]]; then
        TARGET_DIR="$1"
      else
        echo "Error: Unexpected argument: $1" >&2
        exit 1
      fi
      shift
      ;;
  esac
done

if [[ -z "$MODE" ]]; then
  echo "Error: MODE argument is required. See --help for options." >&2
  usage
  exit 1
fi

# Default to current directory if not specified
if [[ -z "$TARGET_DIR" ]]; then
  TARGET_DIR="."
fi

# Convert to absolute path
TARGET_DIR="$(cd "$TARGET_DIR" 2>/dev/null && pwd)" || {
  echo "Error: Target directory does not exist: $TARGET_DIR" >&2
  exit 1
}

if [[ -z "$USER_SHELL_NAME" ]]; then
  USER_SHELL_NAME="$(basename "$USER_SHELL")"
fi

# Track if repo was explicitly set (for auto-detection)
DOTFILES_REPO_EXPLICIT=false
if [[ "$DOTFILES_REPO_WAS_FLAG" == "true" ]]; then
  DOTFILES_REPO_EXPLICIT=true
elif [[ -n "${DOTFILES_REPO:-}" && "$DOTFILES_REPO" != "https://github.com/technicalpickles/dotfiles.git" ]]; then
  DOTFILES_REPO_EXPLICIT=true
fi

# Auto-detect dotfiles repo if not explicitly set
if [[ "$DOTFILES_REPO_EXPLICIT" == "false" ]]; then
  detect_dotfiles_repo
else
  # Explicit override was used
  echo "üîç Using explicitly specified dotfiles repository"
  echo "   Repo: $DOTFILES_REPO"
fi

apply_mode_presets

if is_local_dind_ref "$DIND_FEATURE_REF"; then
  KEEP_VENDORED_FEATURES=true
fi
if is_local_dind_ref "$AWS_CLI_FEATURE_REF"; then
  KEEP_VENDORED_FEATURES=true
fi

echo
echo "Dotfiles Dev Container Template Applier"
echo "========================================"
echo

# Detect context: are we running from the repo or standalone?
IS_IN_REPO=false
if [[ -f "$REPO_ROOT/src/dotfiles/devcontainer-template.json" ]]; then
  IS_IN_REPO=true
fi

if [[ "$IS_IN_REPO" == "true" ]]; then
  echo "üì¶ Running from dotfiles-devcontainer repository"
  echo "   Will use local template files from: src/dotfiles/"
  TEMPLATE_SOURCE="$REPO_ROOT/src/dotfiles"
else
  echo "üåê Running standalone (not in repo)"
  echo "   Will use published template: $TEMPLATE_ID"
  TEMPLATE_SOURCE="$TEMPLATE_ID"
fi

echo
echo "Configuration:"
echo "  Mode: $MODE"
echo "  Target directory: $TARGET_DIR"
echo "  Dotfiles repo: $DOTFILES_REPO"
echo "  Dotfiles branch: $DOTFILES_BRANCH"
echo "  User shell: $USER_SHELL (profile: $USER_SHELL_NAME)"
echo "  Platform: ${PLATFORM_OVERRIDE:-auto-detect}"
if [[ "$SKIP_DIND" == "true" ]]; then
  echo "  Docker-in-Docker: disabled (--no-dind)"
elif [[ -n "$DIND_FEATURE_REF" ]]; then
  echo "  DinD feature ref: $DIND_FEATURE_REF"
fi
if [[ -n "$AWS_CLI_FEATURE_REF" ]]; then
  echo "  AWS CLI feature ref: $AWS_CLI_FEATURE_REF"
fi
if [[ "$KEEP_VENDORED_FEATURES" == "true" ]]; then
  echo "  Feature source: local (vendored features will be kept)"
fi
# Temporarily disable unbound variable check for associative array
set +u
if [[ ${#ENV_VARS[@]} -gt 0 ]]; then
  echo "  Environment variables:"
  for kv in "${ENV_VARS[@]}"; do
    echo "    $kv"
  done
fi
set -u
echo

detect_platform
echo

# Check if devcontainer CLI is installed
if ! command -v devcontainer &> /dev/null; then
  echo "‚ö†Ô∏è  devcontainer CLI not found"
  echo "üì¶ Installing @devcontainers/cli..."

  # Check if npx is available
  if command -v npx &> /dev/null; then
    echo "   Using npx (no installation needed)"
    DEVCONTAINER_CMD="npx --yes @devcontainers/cli"
  elif command -v npm &> /dev/null; then
    echo "   Installing globally with npm..."
    npm install -g @devcontainers/cli
    DEVCONTAINER_CMD="devcontainer"
  else
    echo "Error: Neither npx nor npm found. Please install Node.js first:" >&2
    echo "  https://nodejs.org/" >&2
    exit 1
  fi
else
  echo "‚úì devcontainer CLI found"
  DEVCONTAINER_CMD="devcontainer"
fi

echo

# Check if target directory already has devcontainer config
if [[ -d "$TARGET_DIR/.devcontainer" ]]; then
  echo "‚ö†Ô∏è  Warning: .devcontainer/ already exists in target directory"
  read -p "   Do you want to overwrite it? (y/N) " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Aborted."
    exit 1
  fi
  echo "   Will overwrite existing configuration"
  echo
fi

# Apply the template
echo "üöÄ Applying template to: $TARGET_DIR"
echo

cd "$TARGET_DIR"

if [[ "$IS_IN_REPO" == "true" ]]; then
  # Running from repo - copy files manually since we can't use templates apply with local path
  echo "üìã Copying template files..."

  # Create .devcontainer directory
  mkdir -p .devcontainer

  # Copy devcontainer files
  cp "$TEMPLATE_SOURCE/.devcontainer/devcontainer.json" .devcontainer/
  cp "$TEMPLATE_SOURCE/.devcontainer/Dockerfile" .devcontainer/
  cp "$TEMPLATE_SOURCE/.devcontainer/post-create.sh" .devcontainer/

  # Replace template options with actual values
  echo "üîß Configuring template options..."

  # Build containerEnv JSON for environment variables
  set +u
  if [[ ${#ENV_VARS[@]} -gt 0 ]]; then
    CONTAINER_ENV_JSON="{"
    FIRST=true
    for kv in "${ENV_VARS[@]}"; do
      key="${kv%%=*}"
      value="${kv#*=}"
      if [[ "$FIRST" == "true" ]]; then
        FIRST=false
      else
        CONTAINER_ENV_JSON+=","
      fi
      # Properly escape JSON values
      VALUE=$(printf '%s' "$value" | jq -R .)
      CONTAINER_ENV_JSON+="\"$key\":$VALUE"
    done
    CONTAINER_ENV_JSON+="}"
  else
    CONTAINER_ENV_JSON="{}"
  fi
  set -u

   # Replace placeholders in devcontainer.json
   # Use Python for JSON-aware replacement to handle containerEnv as object, not string
   python3 - .devcontainer/devcontainer.json "$DOTFILES_REPO" "$DOTFILES_BRANCH" "$USER_SHELL" "$USER_SHELL_NAME" "$CONTAINER_ENV_JSON" "$SKIP_DIND" <<'PY'
import json, sys, re
path = sys.argv[1]
dotfiles_repo = sys.argv[2]
dotfiles_branch = sys.argv[3]
user_shell = sys.argv[4]
user_shell_name = sys.argv[5]
container_env_json = sys.argv[6]
skip_dind = sys.argv[7] == "true"

with open(path, 'r', encoding='utf-8') as f:
    raw = f.read()

# Strip JSONC comments for parsing
clean = re.sub(r'^\s*//.*$', '', raw, flags=re.M)
obj = json.loads(clean)

# Replace template options in build args
if 'build' in obj and 'args' in obj['build']:
    args = obj['build']['args']
    if 'DOTFILES_REPO' in args:
        args['DOTFILES_REPO'] = dotfiles_repo
    if 'DOTFILES_BRANCH' in args:
        args['DOTFILES_BRANCH'] = dotfiles_branch
    if 'USER_SHELL' in args:
        args['USER_SHELL'] = user_shell

# Replace containerEnv as proper JSON object (not string)
obj['containerEnv'] = json.loads(container_env_json)

# Replace in customizations
if 'customizations' in obj and 'vscode' in obj['customizations']:
    vscode = obj['customizations']['vscode']
    if 'settings' in vscode:
        settings = vscode['settings']
        if 'terminal.integrated.defaultProfile.linux' in settings:
            settings['terminal.integrated.defaultProfile.linux'] = user_shell_name
        if 'terminal.integrated.profiles.linux' in settings:
            profiles = settings['terminal.integrated.profiles.linux']
            # Replace the shell name key
            old_profiles = dict(profiles)
            profiles.clear()
            for key, val in old_profiles.items():
                new_key = user_shell_name if '${templateOption:userShellName}' in key else key
                if isinstance(val, dict) and 'path' in val:
                    val['path'] = user_shell
                profiles[new_key] = val

# Remove features if skip_dind is true
if skip_dind and 'features' in obj:
    del obj['features']

with open(path, 'w', encoding='utf-8') as f:
    json.dump(obj, f, indent=2)
    f.write('\n')
PY

  # Replace placeholders in Dockerfile
  sed -i.bak "s|\${templateOption:dotfilesRepo}|$DOTFILES_REPO|g" .devcontainer/Dockerfile
  sed -i.bak "s|\${templateOption:dotfilesBranch}|$DOTFILES_BRANCH|g" .devcontainer/Dockerfile
  sed -i.bak "s|\${templateOption:userShell}|$USER_SHELL|g" .devcontainer/Dockerfile
  rm .devcontainer/Dockerfile.bak

  # In local-dev mode, use :local tag instead of pinned digest for base image
  if [[ "$MODE" == "local-dev" ]]; then
    BASE_IMAGE_REPO="ghcr.io/technicalpickles/dotfiles-devcontainer/base"
    LOCAL_TAG="${BASE_IMAGE_REPO}:local"
    # Rewrite FROM line to use :local tag
    sed -i.bak "s|^FROM ${BASE_IMAGE_REPO}@sha256:[a-f0-9]*|FROM ${LOCAL_TAG}|" .devcontainer/Dockerfile
    rm .devcontainer/Dockerfile.bak
    # Check if local image exists
    if ! docker image inspect "${LOCAL_TAG}" >/dev/null 2>&1; then
      echo "‚ö†Ô∏è  Base image not found locally: ${LOCAL_TAG}"
      echo "   Run: bin/build-base --tag ${LOCAL_TAG}"
      echo "   Then retry opening the devcontainer."
    else
      echo "‚úì Using local base image: ${LOCAL_TAG}"
    fi
  fi

  # Replace placeholders in post-create.sh
  sed -i.bak "s|\${templateOption:dotfilesRepo}|$DOTFILES_REPO|g" .devcontainer/post-create.sh
  sed -i.bak "s|\${templateOption:dotfilesBranch}|$DOTFILES_BRANCH|g" .devcontainer/post-create.sh
  rm .devcontainer/post-create.sh.bak

  if [[ "$KEEP_VENDORED_FEATURES" == "true" ]]; then
    echo "üì¶ Copying vendored features for local ref"
    mkdir -p .devcontainer/features
    cp -R "$TEMPLATE_SOURCE/.devcontainer/features/." .devcontainer/features/
  fi

   if [[ -n "$PLATFORM_SELECTED" ]]; then
     python3 - "$PLATFORM_SELECTED" .devcontainer/devcontainer.json "$SKIP_DIND" <<'PY'
import json, sys, re
platform = sys.argv[1]
path = sys.argv[2]
skip_dind = sys.argv[3] == "true"
raw = open(path, 'r', encoding='utf-8').read()
clean = re.sub(r'^\s*//.*$', '', raw, flags=re.M)
obj = json.loads(clean)
build = obj.get('build', {})
options = list(build.get('options', []))
flag = f"--platform={platform}"
if flag not in options:
    options.insert(0, flag)
build['options'] = options
obj['build'] = build

# Remove features if skip_dind is true
if skip_dind and 'features' in obj:
    del obj['features']

with open(path, 'w', encoding='utf-8') as f:
    json.dump(obj, f, indent=2)
    f.write('\n')
PY
   fi

  override_feature_refs
  prune_vendored_features
  echo "‚úì Template files copied and configured"
else
  # Running standalone - use devcontainer CLI with published template
  # Build template args for environment variables
  ENV_ARGS=""
  set +u
  if [[ ${#ENV_VARS[@]} -gt 0 ]]; then
    ENV_JSON="{"
    FIRST=true
    for kv in "${ENV_VARS[@]}"; do
      key="${kv%%=*}"
      value="${kv#*=}"
      if [[ "$FIRST" == "true" ]]; then
        FIRST=false
      else
        ENV_JSON+=","
      fi
      VALUE=$(printf '%s' "$value" | jq -R .)
      ENV_JSON+="\"$key\":$VALUE"
    done
    ENV_JSON+="}"
    ENV_ARGS="--template-args installEnvVars='$ENV_JSON'"
  fi
  set -u

  $DEVCONTAINER_CMD templates apply \
    --template-id "$TEMPLATE_ID" \
    --template-args dotfilesRepo="$DOTFILES_REPO" \
    --template-args dotfilesBranch="$DOTFILES_BRANCH" \
    --template-args userShell="$USER_SHELL" \
    --template-args userShellName="$USER_SHELL_NAME" \
    $ENV_ARGS

   if [[ -n "$PLATFORM_SELECTED" && -f ".devcontainer/devcontainer.json" ]]; then
     python3 - "$PLATFORM_SELECTED" .devcontainer/devcontainer.json "$SKIP_DIND" <<'PY'
import json, sys, re
platform = sys.argv[1]
path = sys.argv[2]
skip_dind = sys.argv[3] == "true"
raw = open(path, 'r', encoding='utf-8').read()
clean = re.sub(r'^\s*//.*$', '', raw, flags=re.M)
obj = json.loads(clean)
build = obj.get('build', {})
options = list(build.get('options', []))
flag = f"--platform={platform}"
if flag not in options:
    options.insert(0, flag)
build['options'] = options
obj['build'] = build

# Remove features if skip_dind is true
if skip_dind and 'features' in obj:
    del obj['features']

with open(path, 'w', encoding='utf-8') as f:
    json.dump(obj, f, indent=2)
    f.write('\n')
PY
   fi

  override_feature_refs
  prune_vendored_features
  echo "‚úì Template applied via devcontainer CLI"
fi

echo
echo "‚úÖ Success! Dotfiles devcontainer template has been applied."
echo
echo "Next steps:"
echo "  1. Review the configuration in .devcontainer/"
echo "  2. Open this directory in VS Code"
echo "  3. Press Cmd+Shift+P and select 'Dev Containers: Reopen in Container'"
echo
echo "For better performance on macOS, consider using:"
echo "  'Dev Containers: Clone Repository in Container Volume...'"
echo "  See: https://github.com/technicalpickles/dotfiles-devcontainer#macos-performance-optimization"
echo
